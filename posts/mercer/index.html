<!DOCTYPE html>
<head>
  <meta charset="utf-8"/>
  <title>Mercer&#39;s Theorem and SVMs &mdash; Patterns of Ideas</title>
  <link rel="stylesheet" type="text/css" href="/static/tufte.css">
  <link rel="stylesheet" type="text/css" href="/static/latex.min.css">
  <link rel="stylesheet" type="text/css" href="/static/pygments.min.css">
  <script type="text/javascript" src="/static/enquire.min.js"></script>
  <script type="text/javascript" src="/static/jquery-1.12.4.min.js"></script>
  <script type="text/javascript" src="/static/resources.min.js"></script>
  <script type="text/javascript" src="/static/LaTeXMathML.min.js"></script>
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <link rel='shortcut icon' href="/static/favicon.ico" type='image/x-icon'/>
  <style type="text/css">
   img { mix-blend-mode: multiply; }
  </style>
  <meta property="og:author" content="Samir Khan" />
  <meta property="og:title" content="Mercer&#39;s Theorem and SVMs" />
  <meta property="og:type" content="website" />
  <meta property="og:description" content="A proof of Mercer&#39;s theorem and an application to SVMs." />
  <meta property="og:url" content="/posts/mercer/" />
  <meta property="og:image" content="/static/img/athena.png" />
  <meta name="twitter:card" content="summary" />
  <meta name="twitter:title" content="Mercer&#39;s Theorem and SVMs" />
  <meta name="twitter:description" content="A proof of Mercer&#39;s theorem and an application to SVMs." />
  <meta name="twitter:url" content="/posts/mercer/" />
  <meta name="twitter:image" content="/static/img/athena.png" />
  <script src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML" type="text/javascript"></script>
</head>
<body>
  <div class="thearticle">

  <article>
  
    <h1>Mercer&#39;s Theorem and SVMs</h1>
    <p id="blog-p"><span id="blogdesc" class="marginnote">
    A personal blog by Samir Khan<br><br>
    <a href="/">home</a> ·
    
      <a href="/about/">
        about</a>
    </span></p>

    <subtitle class="sub-date">December 12, 2016 · <span style="font-size: 1.6rem;"><a style="border-bottom-width: 0px !important;" href="/posts/mercer/">&infin;</a></span></subtitle>

    <!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
  <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
  <meta http-equiv="Content-Style-Type" content="text/css" />
  <meta name="generator" content="pandoc" />
  <title></title>
  <style type="text/css">code{white-space: pre;}</style>
</head>
<body>
<p>In a funny coincidence, this post has the same basic structure as the previous one: proving some technical result, and then looking at an application to machine learning. This time it’s Mercer’s theorem from functional analysis, and the kernel trick for SVMs. The proof of Mercer’s theorem mostly follows Lax’s <em>Functional Analysis</em>.</p>
<h2 id="mercers-theorem">1. Mercer’s Theorem</h2>
<p>Consider a real-valued function <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>K</mi><mo stretchy="false" form="prefix">(</mo><mi>s</mi><mo>,</mo><mi>t</mi><mo stretchy="false" form="postfix">)</mo></mrow><annotation encoding="application/x-tex">K(s,t)</annotation></semantics></math>, and the corresponding integral operator <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mstyle mathvariant="bold"><mi>𝐊</mi></mstyle><mo>:</mo><msup><mi>L</mi><mn>2</mn></msup><mo stretchy="false" form="prefix">[</mo><mn>0</mn><mo>,</mo><mn>1</mn><mo stretchy="false" form="postfix">]</mo><mo accent="false">→</mo><msup><mi>L</mi><mn>2</mn></msup><mo stretchy="false" form="prefix">[</mo><mn>0</mn><mo>,</mo><mn>1</mn><mo stretchy="false" form="postfix">]</mo></mrow><annotation encoding="application/x-tex">\mathbf{K}: L^2[0,1]\to L^2[0,1]</annotation></semantics></math> given by <math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false" form="prefix">(</mo><mstyle mathvariant="bold"><mi>𝐊</mi></mstyle><mi>u</mi><mo stretchy="false" form="postfix">)</mo><mo stretchy="false" form="prefix">(</mo><mi>s</mi><mo stretchy="false" form="postfix">)</mo><mo>=</mo><msubsup><mo>∫</mo><mn>0</mn><mn>1</mn></msubsup><mi>K</mi><mo stretchy="false" form="prefix">(</mo><mi>s</mi><mo>,</mo><mi>t</mi><mo stretchy="false" form="postfix">)</mo><mi>u</mi><mo stretchy="false" form="prefix">(</mo><mi>t</mi><mo stretchy="false" form="postfix">)</mo><mspace width="0.167em"></mspace><mi>d</mi><mi>t</mi><mi>.</mi></mrow><annotation encoding="application/x-tex">(\mathbf{K}  u)(s)=\int_0^1 K(s,t) u(t)\, dt.</annotation></semantics></math> We begin with two facts connecting the properties of <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>K</mi><annotation encoding="application/x-tex">K</annotation></semantics></math> to the properties of <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mstyle mathvariant="bold"><mi>𝐊</mi></mstyle><annotation encoding="application/x-tex">\mathbf{K}</annotation></semantics></math>.</p>
<p><strong>Proposition 1.</strong> <em>If <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>K</mi><annotation encoding="application/x-tex">K</annotation></semantics></math> is continuous, then <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mstyle mathvariant="bold"><mi>𝐊</mi></mstyle><annotation encoding="application/x-tex">\mathbf{K}</annotation></semantics></math> is compact.</em></p>
<p><em>Proof.</em> Consider a bounded sequence <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false" form="prefix">{</mo><msub><mi>f</mi><mi>n</mi></msub><msubsup><mo stretchy="false" form="postfix">}</mo><mrow><mi>n</mi><mo>=</mo><mn>1</mn></mrow><mi>∞</mi></msubsup><mo>⊂</mo><msup><mi>L</mi><mn>2</mn></msup><mo stretchy="false" form="prefix">[</mo><mn>0</mn><mo>,</mo><mn>1</mn><mo stretchy="false" form="postfix">]</mo></mrow><annotation encoding="application/x-tex">\{f_n\}_{n=1}^{\infty} \subset L^2[0,1]</annotation></semantics></math>. We wish to show that the image of this sequence, <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false" form="prefix">{</mo><mstyle mathvariant="bold"><mi>𝐊</mi></mstyle><msub><mi>f</mi><mi>n</mi></msub><msubsup><mo stretchy="false" form="postfix">}</mo><mrow><mi>n</mi><mo>=</mo><mn>1</mn></mrow><mi>∞</mi></msubsup></mrow><annotation encoding="application/x-tex">\{\mathbf{K} f_n\}_{n=1}^{\infty}</annotation></semantics></math>, has a convergent subsequence. We show that <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false" form="prefix">{</mo><mstyle mathvariant="bold"><mi>𝐊</mi></mstyle><msub><mi>f</mi><mi>n</mi></msub><mo stretchy="false" form="postfix">}</mo></mrow><annotation encoding="application/x-tex">\{\mathbf{K} f_n\}</annotation></semantics></math> is equicontinuous, and Arzela-Ascoli then gives a uniformly convergent subsequence, which in turns gives that <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mstyle mathvariant="bold"><mi>𝐊</mi></mstyle><annotation encoding="application/x-tex">\mathbf{K}</annotation></semantics></math> is compact.</p>
<p>Since <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>K</mi><mo stretchy="false" form="prefix">(</mo><mi>x</mi><mo>,</mo><mi>y</mi><mo stretchy="false" form="postfix">)</mo></mrow><annotation encoding="application/x-tex">K(x,y)</annotation></semantics></math> is continuous, for every <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>ϵ</mi><mo>&gt;</mo><mn>0</mn></mrow><annotation encoding="application/x-tex">\epsilon&gt;0</annotation></semantics></math>, there exists <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>δ</mi><mo>&gt;</mo><mn>0</mn></mrow><annotation encoding="application/x-tex">\delta&gt;0</annotation></semantics></math> such that <math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false" form="prefix">|</mo><mi>x</mi><mo>−</mo><mover><mi>x</mi><mo accent="true">̃</mo></mover><mo stretchy="false" form="prefix">|</mo><mo>&lt;</mo><mi>δ</mi><mo accent="false">⟹</mo><mo stretchy="false" form="prefix">|</mo><mi>K</mi><mo stretchy="false" form="prefix">(</mo><mi>x</mi><mo>,</mo><mi>y</mi><mo stretchy="false" form="postfix">)</mo><mo>−</mo><mi>K</mi><mo stretchy="false" form="prefix">(</mo><mover><mi>x</mi><mo accent="true">̃</mo></mover><mo>,</mo><mi>y</mi><mo stretchy="false" form="postfix">)</mo><mo stretchy="false" form="prefix">|</mo><mo>≤</mo><mi>ϵ</mi><mi>.</mi></mrow><annotation encoding="application/x-tex">|x-\tilde{x}|&lt;\delta \implies |K(x,y)-K(\tilde{x}, y)|\leq \epsilon.</annotation></semantics></math> Then, if <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false" form="prefix">|</mo><mi>x</mi><mo>−</mo><mover><mi>x</mi><mo accent="true">̃</mo></mover><mo stretchy="false" form="prefix">|</mo><mo>&lt;</mo><mi>δ</mi></mrow><annotation encoding="application/x-tex">|x-\tilde{x}|&lt;\delta</annotation></semantics></math>, we have that <math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false" form="prefix">|</mo><mstyle mathvariant="bold"><mi>𝐊</mi></mstyle><msub><mi>f</mi><mi>n</mi></msub><mo stretchy="false" form="prefix">(</mo><mi>x</mi><mo stretchy="false" form="postfix">)</mo><mo>−</mo><mstyle mathvariant="bold"><mi>𝐊</mi></mstyle><msub><mi>f</mi><mi>n</mi></msub><mo stretchy="false" form="prefix">(</mo><mover><mi>x</mi><mo accent="true">̃</mo></mover><mo stretchy="false" form="postfix">)</mo><mo stretchy="false" form="prefix">|</mo><mo>=</mo><mrow><mo stretchy="true" form="prefix">|</mo><msubsup><mo>∫</mo><mn>0</mn><mn>1</mn></msubsup><mi>K</mi><mo stretchy="false" form="prefix">(</mo><mi>x</mi><mo>,</mo><mi>t</mi><mo stretchy="false" form="postfix">)</mo><msub><mi>f</mi><mi>n</mi></msub><mo stretchy="false" form="prefix">(</mo><mi>t</mi><mo stretchy="false" form="postfix">)</mo><mspace width="0.167em"></mspace><mi>d</mi><mi>t</mi><mo stretchy="true" form="postfix">|</mo></mrow><mo>−</mo><mrow><mo stretchy="true" form="prefix">|</mo><msubsup><mo>∫</mo><mn>0</mn><mn>1</mn></msubsup><mi>K</mi><mo stretchy="false" form="prefix">(</mo><mover><mi>x</mi><mo accent="true">̃</mo></mover><mo>,</mo><mi>t</mi><mo stretchy="false" form="postfix">)</mo><msub><mi>f</mi><mi>n</mi></msub><mo stretchy="false" form="prefix">(</mo><mi>t</mi><mo stretchy="false" form="postfix">)</mo><mspace width="0.167em"></mspace><mi>d</mi><mi>t</mi><mo stretchy="true" form="postfix">|</mo></mrow></mrow><annotation encoding="application/x-tex">|\mathbf{K}  f_n(x)- \mathbf{K}  f_n(\tilde{x})| = \left| \int_0^1 K(x, t) f_n(t)\, dt \right| -\left| \int_0^1 K(\tilde{x}, t) f_n(t)\, dt \right|</annotation></semantics></math> which is bounded by <math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msubsup><mo>∫</mo><mn>0</mn><mn>1</mn></msubsup><mo stretchy="false" form="prefix">|</mo><mi>K</mi><mo stretchy="false" form="prefix">(</mo><mi>x</mi><mo>,</mo><mi>t</mi><mo stretchy="false" form="postfix">)</mo><mo>−</mo><mi>K</mi><mo stretchy="false" form="prefix">(</mo><mover><mi>x</mi><mo accent="true">̃</mo></mover><mo>,</mo><mi>t</mi><mo stretchy="false" form="postfix">)</mo><mo stretchy="false" form="prefix">|</mo><mo stretchy="false" form="prefix">|</mo><msub><mi>f</mi><mi>n</mi></msub><mo stretchy="false" form="prefix">(</mo><mi>t</mi><mo stretchy="false" form="postfix">)</mo><mo stretchy="false" form="prefix">|</mo><mspace width="0.167em"></mspace><mi>d</mi><mi>t</mi><mo>≤</mo><mi>ϵ</mi><msubsup><mo>∫</mo><mn>0</mn><mn>1</mn></msubsup><mo stretchy="false" form="prefix">|</mo><msub><mi>f</mi><mi>n</mi></msub><mo stretchy="false" form="prefix">(</mo><mi>t</mi><mo stretchy="false" form="postfix">)</mo><mo stretchy="false" form="prefix">|</mo><mspace width="0.167em"></mspace><mi>d</mi><mi>t</mi><mo>≤</mo><mi>ϵ</mi><mi>M</mi><mo>,</mo></mrow><annotation encoding="application/x-tex">\int_0^1 |K(x,t)-K(\tilde{x},t)|  |f_n(t)| \, dt \leq \epsilon \int_0^1 |f_n(t)|\, dt\leq  \epsilon M,</annotation></semantics></math></p>
<p>where <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>M</mi><annotation encoding="application/x-tex">M</annotation></semantics></math> is an upper bound on the norm of the <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msub><mi>f</mi><mi>n</mi></msub><annotation encoding="application/x-tex">f_n</annotation></semantics></math>. The equicontinuity of the <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mstyle mathvariant="bold"><mi>𝐊</mi></mstyle><msub><mi>f</mi><mi>n</mi></msub></mrow><annotation encoding="application/x-tex">\mathbf{K} f_n</annotation></semantics></math>, and thus the compactness of <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mstyle mathvariant="bold"><mi>𝐊</mi></mstyle><annotation encoding="application/x-tex">\mathbf{K}</annotation></semantics></math>, follows. <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>◼</mi><annotation encoding="application/x-tex">\blacksquare</annotation></semantics></math></p>
<p><strong>Proposition 2.</strong> <em>If <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>K</mi><annotation encoding="application/x-tex">K</annotation></semantics></math> is symmetric, then <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mstyle mathvariant="bold"><mi>𝐊</mi></mstyle><annotation encoding="application/x-tex">\mathbf{K}</annotation></semantics></math> is self-adjoint.</em></p>
<p><em>Proof.</em> We directly compute that <math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false" form="prefix">⟨</mo><mstyle mathvariant="bold"><mi>𝐊</mi></mstyle><mi>u</mi><mo>,</mo><mi>v</mi><mo stretchy="false" form="postfix">⟩</mo><mo>=</mo><msubsup><mo>∫</mo><mn>0</mn><mn>1</mn></msubsup><msubsup><mo>∫</mo><mn>0</mn><mn>1</mn></msubsup><mi>K</mi><mo stretchy="false" form="prefix">(</mo><mi>s</mi><mo>,</mo><mi>t</mi><mo stretchy="false" form="postfix">)</mo><mspace width="0.167em"></mspace><mi>u</mi><mo stretchy="false" form="prefix">(</mo><mi>s</mi><mo stretchy="false" form="postfix">)</mo><mi>v</mi><mo stretchy="false" form="prefix">(</mo><mi>t</mi><mo stretchy="false" form="postfix">)</mo><mspace width="0.167em"></mspace><mi>d</mi><mi>s</mi><mspace width="0.167em"></mspace><mi>d</mi><mi>t</mi></mrow><annotation encoding="application/x-tex">\langle \mathbf{K}  u, v\rangle = \int_0^1\int_0^1 K(s,t)\, u(s) v(t)\, ds\, dt</annotation></semantics></math> and <math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false" form="prefix">⟨</mo><mi>u</mi><mo>,</mo><mstyle mathvariant="bold"><mi>𝐊</mi></mstyle><mi>v</mi><mo stretchy="false" form="postfix">⟩</mo><mo>=</mo><msubsup><mo>∫</mo><mn>0</mn><mn>1</mn></msubsup><msubsup><mo>∫</mo><mn>0</mn><mn>1</mn></msubsup><mi>K</mi><mo stretchy="false" form="prefix">(</mo><mi>t</mi><mo>,</mo><mi>s</mi><mo stretchy="false" form="postfix">)</mo><mspace width="0.167em"></mspace><mi>u</mi><mo stretchy="false" form="prefix">(</mo><mi>s</mi><mo stretchy="false" form="postfix">)</mo><mi>v</mi><mo stretchy="false" form="prefix">(</mo><mi>t</mi><mo stretchy="false" form="postfix">)</mo><mspace width="0.167em"></mspace><mi>d</mi><mi>s</mi><mspace width="0.167em"></mspace><mi>d</mi><mi>t</mi><mo>,</mo></mrow><annotation encoding="application/x-tex">\langle u, \mathbf{K}  v\rangle  = \int_0^1\int_0^1 K(t,s)\, u(s) v(t)\, ds\, dt,</annotation></semantics></math> which will be equal if <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>K</mi><mo stretchy="false" form="prefix">(</mo><mi>s</mi><mo>,</mo><mi>t</mi><mo stretchy="false" form="postfix">)</mo><mo>=</mo><mi>K</mi><mo stretchy="false" form="prefix">(</mo><mi>t</mi><mo>,</mo><mi>s</mi><mo stretchy="false" form="postfix">)</mo></mrow><annotation encoding="application/x-tex">K(s,t)=K(t,s)</annotation></semantics></math>, so <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mstyle mathvariant="bold"><mi>𝐊</mi></mstyle><annotation encoding="application/x-tex">\mathbf{K}</annotation></semantics></math> is self-adjoint in this case. <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>◼</mi><annotation encoding="application/x-tex">\blacksquare</annotation></semantics></math></p>
<p>Thus, when <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>K</mi><annotation encoding="application/x-tex">K</annotation></semantics></math> is continuous and symmetric, the operator <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mstyle mathvariant="bold"><mi>𝐊</mi></mstyle><annotation encoding="application/x-tex">\mathbf{K}</annotation></semantics></math> is a compact self-adjoint operator, and so we can apply the spectral theorem to find a set of orthonormal eigenfunctions <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msub><mi>e</mi><mi>j</mi></msub><annotation encoding="application/x-tex">e_j</annotation></semantics></math> with real eigenvalues <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msub><mi>κ</mi><mi>j</mi></msub><annotation encoding="application/x-tex">\kappa_j</annotation></semantics></math> that form a basis for <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mi>L</mi><mn>2</mn></msup><mo stretchy="false" form="prefix">[</mo><mn>0</mn><mo>,</mo><mn>1</mn><mo stretchy="false" form="postfix">]</mo></mrow><annotation encoding="application/x-tex">L^2[0,1]</annotation></semantics></math>. The following theorem connects <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>K</mi><annotation encoding="application/x-tex">K</annotation></semantics></math> to these eigenfunctions and eigenvalues in the case where <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mstyle mathvariant="bold"><mi>𝐊</mi></mstyle><annotation encoding="application/x-tex">\mathbf{K}</annotation></semantics></math> is positive.</p>
<p><strong>Theorem 3 (Mercer).</strong> <em>If <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>K</mi><annotation encoding="application/x-tex">K</annotation></semantics></math> is symmetric and continuous, and the associated operator <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mstyle mathvariant="bold"><mi>𝐊</mi></mstyle><annotation encoding="application/x-tex">\mathbf{K}</annotation></semantics></math> is positive i.e. <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false" form="prefix">⟨</mo><mstyle mathvariant="bold"><mi>𝐊</mi></mstyle><mi>u</mi><mo>,</mo><mi>u</mi><mo stretchy="false" form="postfix">⟩</mo><mo>≥</mo><mn>0</mn></mrow><annotation encoding="application/x-tex">\langle \mathbf{K} u, u\rangle \geq 0</annotation></semantics></math> for all <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>u</mi><annotation encoding="application/x-tex">u</annotation></semantics></math>, then we can write <math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>K</mi><mo stretchy="false" form="prefix">(</mo><mi>s</mi><mo>,</mo><mi>t</mi><mo stretchy="false" form="postfix">)</mo><mo>=</mo><munderover><mo>∑</mo><mrow><mi>j</mi><mo>=</mo><mn>1</mn></mrow><mi>∞</mi></munderover><msub><mi>κ</mi><mi>j</mi></msub><msub><mi>e</mi><mi>j</mi></msub><mo stretchy="false" form="prefix">(</mo><mi>s</mi><mo stretchy="false" form="postfix">)</mo><msub><mi>e</mi><mi>j</mi></msub><mo stretchy="false" form="prefix">(</mo><mi>t</mi><mo stretchy="false" form="postfix">)</mo><mo>,</mo></mrow><annotation encoding="application/x-tex">K(s,t)=\sum_{j=1}^{\infty} \kappa_j e_j(s)e_j(t),</annotation></semantics></math> where the <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msub><mi>κ</mi><mi>j</mi></msub><annotation encoding="application/x-tex">\kappa_j</annotation></semantics></math> and <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msub><mi>e</mi><mi>j</mi></msub><annotation encoding="application/x-tex">e_j</annotation></semantics></math> are the eigenfunctions and eigenvalues of <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mstyle mathvariant="bold"><mi>𝐊</mi></mstyle><annotation encoding="application/x-tex">\mathbf{K}</annotation></semantics></math>.</em></p>
<p>To prove this, we’ll need a lemma.</p>
<p><strong>Lemma 4.</strong> <em>If <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mstyle mathvariant="bold"><mi>𝐊</mi></mstyle><annotation encoding="application/x-tex">\mathbf{K}</annotation></semantics></math> is positive, then <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>K</mi><annotation encoding="application/x-tex">K</annotation></semantics></math> is non-negative on the diagonal.</em></p>
<p><em>Proof.</em> Suppose for the sake of contradiction that <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>K</mi><mo stretchy="false" form="prefix">(</mo><mi>r</mi><mo>,</mo><mi>r</mi><mo stretchy="false" form="postfix">)</mo><mo>&lt;</mo><mn>0</mn></mrow><annotation encoding="application/x-tex">K(r,r)&lt;0</annotation></semantics></math> for some <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>r</mi><annotation encoding="application/x-tex">r</annotation></semantics></math>. Choose <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>s</mi><mo>,</mo><mi>t</mi></mrow><annotation encoding="application/x-tex">s,t</annotation></semantics></math> so close to <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>r</mi><annotation encoding="application/x-tex">r</annotation></semantics></math> that <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>K</mi><mo stretchy="false" form="prefix">(</mo><mi>s</mi><mo>,</mo><mi>t</mi><mo stretchy="false" form="postfix">)</mo></mrow><annotation encoding="application/x-tex">K(s,t)</annotation></semantics></math> is negative, and choose <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>u</mi><annotation encoding="application/x-tex">u</annotation></semantics></math> to be a bump function that is zero except in a small neighborhood around <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false" form="prefix">(</mo><mi>r</mi><mo>,</mo><mi>r</mi><mo stretchy="false" form="postfix">)</mo></mrow><annotation encoding="application/x-tex">(r,r)</annotation></semantics></math>. Then, <math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false" form="prefix">⟨</mo><mstyle mathvariant="bold"><mi>𝐊</mi></mstyle><mi>u</mi><mo>,</mo><mi>u</mi><mo stretchy="false" form="postfix">⟩</mo><mo>=</mo><msubsup><mo>∫</mo><mn>0</mn><mn>1</mn></msubsup><msubsup><mo>∫</mo><mn>0</mn><mn>1</mn></msubsup><mi>K</mi><mo stretchy="false" form="prefix">(</mo><mi>s</mi><mo>,</mo><mi>t</mi><mo stretchy="false" form="postfix">)</mo><mi>u</mi><mo stretchy="false" form="prefix">(</mo><mi>t</mi><mo stretchy="false" form="postfix">)</mo><mi>u</mi><mo stretchy="false" form="prefix">(</mo><mi>s</mi><mo stretchy="false" form="postfix">)</mo><mspace width="0.167em"></mspace><mi>d</mi><mi>s</mi><mspace width="0.167em"></mspace><mi>d</mi><mi>t</mi></mrow><annotation encoding="application/x-tex">\langle \mathbf{K}  u, u\rangle = \int_0^1\int_0^1 K(s,t) u(t) u(s)\, ds \, dt</annotation></semantics></math> will be negative, contradicting the positivity of <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mstyle mathvariant="bold"><mi>𝐊</mi></mstyle><annotation encoding="application/x-tex">\mathbf{K}</annotation></semantics></math>.<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>◼</mi><annotation encoding="application/x-tex">\blacksquare</annotation></semantics></math></p>
<p><em>Proof of Mercer’s Theorem.</em> Define a sequence of functions <math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>K</mi><mi>N</mi></msub><mo stretchy="false" form="prefix">(</mo><mi>s</mi><mo>,</mo><mi>t</mi><mo stretchy="false" form="postfix">)</mo><mo>=</mo><munderover><mo>∑</mo><mrow><mi>j</mi><mo>=</mo><mn>1</mn></mrow><mi>N</mi></munderover><msub><mi>κ</mi><mi>j</mi></msub><msub><mi>e</mi><mi>j</mi></msub><mo stretchy="false" form="prefix">(</mo><mi>s</mi><mo stretchy="false" form="postfix">)</mo><msub><mi>e</mi><mi>j</mi></msub><mo stretchy="false" form="prefix">(</mo><mi>t</mi><mo stretchy="false" form="postfix">)</mo><mo>,</mo></mrow><annotation encoding="application/x-tex">K_N(s,t)=\sum_{j=1}^N \kappa_j e_j(s) e_j(t),</annotation></semantics></math> and let <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msub><mstyle mathvariant="bold"><mi>𝐊</mi></mstyle><mi>N</mi></msub><annotation encoding="application/x-tex">\mathbf{K}_N</annotation></semantics></math> be the associated sequence of integral operators. We first show that the <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msub><mi>K</mi><mi>N</mi></msub><annotation encoding="application/x-tex">K_N</annotation></semantics></math> converge uniformly.</p>
<p>The operator <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mstyle mathvariant="bold"><mi>𝐊</mi></mstyle><mo>−</mo><msub><mstyle mathvariant="bold"><mi>𝐊</mi></mstyle><mi>N</mi></msub></mrow><annotation encoding="application/x-tex">\mathbf{K} -\mathbf{K}_N</annotation></semantics></math> has eigenfunctions <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msub><mi>e</mi><mi>j</mi></msub><annotation encoding="application/x-tex">e_j</annotation></semantics></math> and eigenvalues <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msub><mi>κ</mi><mi>j</mi></msub><annotation encoding="application/x-tex">\kappa_j</annotation></semantics></math> for <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>j</mi><mo>&gt;</mo><mi>N</mi></mrow><annotation encoding="application/x-tex">j&gt;N</annotation></semantics></math>, so it is a positive operator. But then <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>K</mi><mo>−</mo><msub><mi>K</mi><mi>N</mi></msub></mrow><annotation encoding="application/x-tex">K-K_N</annotation></semantics></math> must be non-negative on the diagonal by our lemma, and so <math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>K</mi><mo stretchy="false" form="prefix">(</mo><mi>s</mi><mo>,</mo><mi>s</mi><mo stretchy="false" form="postfix">)</mo><mo>−</mo><munderover><mo>∑</mo><mrow><mi>j</mi><mo>=</mo><mn>1</mn></mrow><mi>N</mi></munderover><msub><mi>κ</mi><mi>j</mi></msub><msubsup><mi>e</mi><mi>j</mi><mn>2</mn></msubsup><mo stretchy="false" form="prefix">(</mo><mi>s</mi><mo stretchy="false" form="postfix">)</mo><mo>≥</mo><mn>0</mn><mo accent="false">⟹</mo><mi>K</mi><mo stretchy="false" form="prefix">(</mo><mi>s</mi><mo>,</mo><mi>s</mi><mo stretchy="false" form="postfix">)</mo><mo>≥</mo><munderover><mo>∑</mo><mrow><mi>j</mi><mo>=</mo><mn>1</mn></mrow><mi>N</mi></munderover><msub><mi>κ</mi><mi>j</mi></msub><msubsup><mi>e</mi><mi>j</mi><mn>2</mn></msubsup><mo stretchy="false" form="prefix">(</mo><mi>s</mi><mo stretchy="false" form="postfix">)</mo></mrow><annotation encoding="application/x-tex">K(s,s)-\sum_{j=1}^N \kappa_j e_j^2(s)\geq 0\implies K(s,s)\geq \sum_{j=1}^N \kappa_j e_j^2(s)</annotation></semantics></math> for all <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>N</mi><annotation encoding="application/x-tex">N</annotation></semantics></math>. Since the sum on the right is always non-negative, it must converge for every <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>s</mi><annotation encoding="application/x-tex">s</annotation></semantics></math>. This gives point-wise monotone convergence of the sequence of partial sums, which means they converge uniformly in <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>s</mi><annotation encoding="application/x-tex">s</annotation></semantics></math>.</p>
<p>But now by Cauchy-Schwarz, <math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mrow><mo stretchy="true" form="prefix">|</mo><munderover><mo>∑</mo><mrow><mi>j</mi><mo>=</mo><mn>1</mn></mrow><mi>N</mi></munderover><msub><mi>κ</mi><mi>j</mi></msub><msub><mi>e</mi><mi>j</mi></msub><mo stretchy="false" form="prefix">(</mo><mi>s</mi><mo stretchy="false" form="postfix">)</mo><msub><mi>e</mi><mi>j</mi></msub><mo stretchy="false" form="prefix">(</mo><mi>t</mi><mo stretchy="false" form="postfix">)</mo><mo stretchy="true" form="postfix">|</mo></mrow><mo>≤</mo><msup><mrow><mo stretchy="true" form="prefix">(</mo><munderover><mo>∑</mo><mrow><mi>j</mi><mo>=</mo><mn>1</mn></mrow><mi>N</mi></munderover><msub><mi>κ</mi><mi>j</mi></msub><msubsup><mi>e</mi><mi>j</mi><mn>2</mn></msubsup><mo stretchy="false" form="prefix">(</mo><mi>s</mi><mo stretchy="false" form="postfix">)</mo><mo stretchy="true" form="postfix">)</mo></mrow><mrow><mn>1</mn><mi>/</mi><mn>2</mn></mrow></msup><msup><mrow><mo stretchy="true" form="prefix">(</mo><munderover><mo>∑</mo><mrow><mi>j</mi><mo>=</mo><mn>1</mn></mrow><mi>N</mi></munderover><msub><mi>κ</mi><mi>j</mi></msub><msubsup><mi>e</mi><mi>j</mi><mn>2</mn></msubsup><mo stretchy="false" form="prefix">(</mo><mi>t</mi><mo stretchy="false" form="postfix">)</mo><mo stretchy="true" form="postfix">)</mo></mrow><mrow><mn>1</mn><mi>/</mi><mn>2</mn></mrow></msup><mo>,</mo></mrow><annotation encoding="application/x-tex">\left|\sum_{j=1}^N \kappa_j e_j(s) e_j(t)\right| \leq \left(\sum_{j=1}^N \kappa_j e_j^2(s)\right)^{1/2}\left(\sum_{j=1}^N \kappa_j e_j^2(t)\right)^{1/2},</annotation></semantics></math> and since both of the series on the right converge uniformly, the series on the left does as well.</p>
<p>Let <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msub><mi>K</mi><mi>∞</mi></msub><annotation encoding="application/x-tex">K_{\infty}</annotation></semantics></math> be the limit of the <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msub><mi>K</mi><mi>N</mi></msub><annotation encoding="application/x-tex">K_N</annotation></semantics></math>. Then, by definition, <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mstyle mathvariant="bold"><mi>𝐊</mi></mstyle><annotation encoding="application/x-tex">\mathbf{K}</annotation></semantics></math> and <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msub><mstyle mathvariant="bold"><mi>𝐊</mi></mstyle><mi>∞</mi></msub><annotation encoding="application/x-tex">\mathbf{K}_{\infty}</annotation></semantics></math> agree on all of the <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msub><mi>e</mi><mi>j</mi></msub><annotation encoding="application/x-tex">e_j</annotation></semantics></math> and their linear combinations, and since the <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msub><mi>e</mi><mi>j</mi></msub><annotation encoding="application/x-tex">e_j</annotation></semantics></math> span the space, this means <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mstyle mathvariant="bold"><mi>𝐊</mi></mstyle><annotation encoding="application/x-tex">\mathbf{K}</annotation></semantics></math> and <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msub><mstyle mathvariant="bold"><mi>𝐊</mi></mstyle><mi>∞</mi></msub><annotation encoding="application/x-tex">\mathbf{K}_{\infty}</annotation></semantics></math> agree everywhere, and so they must be the same operator. But this means they have the same kernel, so <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>K</mi><mo>=</mo><msub><mi>K</mi><mi>∞</mi></msub></mrow><annotation encoding="application/x-tex">K= K_{\infty}</annotation></semantics></math>, completing the proof. <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>◼</mi><annotation encoding="application/x-tex">\blacksquare</annotation></semantics></math></p>
<h2 id="the-kernel-trick">2. The Kernel Trick</h2>
<p>The basic idea of the kernel trick is this: let’s say you have some data points <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mstyle mathvariant="bold"><mi>𝐱</mi></mstyle><mn>1</mn></msub><mo>,</mo><msub><mstyle mathvariant="bold"><mi>𝐱</mi></mstyle><mn>2</mn></msub><mo>,</mo><mi>⋯</mi><mo>,</mo><msub><mstyle mathvariant="bold"><mi>𝐱</mi></mstyle><mi>N</mi></msub></mrow><annotation encoding="application/x-tex">\mathbf{x}_1, \mathbf{x}_2,\cdots, \mathbf{x}_N</annotation></semantics></math>. If you want to transform these data points by some map <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>ϕ</mi><annotation encoding="application/x-tex">\phi</annotation></semantics></math>, you have to apply <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>ϕ</mi><annotation encoding="application/x-tex">\phi</annotation></semantics></math> to all of them, and if you want to run an SVM, you have to compute all <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msup><mi>N</mi><mn>2</mn></msup><annotation encoding="application/x-tex">N^2</annotation></semantics></math> dot products <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>ϕ</mi><mo stretchy="false" form="prefix">(</mo><msub><mstyle mathvariant="bold"><mi>𝐱</mi></mstyle><mi>i</mi></msub><mo stretchy="false" form="postfix">)</mo><mo>⋅</mo><mi>ϕ</mi><mo stretchy="false" form="prefix">(</mo><msub><mstyle mathvariant="bold"><mi>𝐱</mi></mstyle><mi>j</mi></msub><mo stretchy="false" form="postfix">)</mo></mrow><annotation encoding="application/x-tex">\phi(\mathbf{x}_i)\cdot \phi(\mathbf{x}_j)</annotation></semantics></math>. For large <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>N</mi><annotation encoding="application/x-tex">N</annotation></semantics></math>, this can be a huge pain, so the dream is to choose <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>ϕ</mi><annotation encoding="application/x-tex">\phi</annotation></semantics></math> so that you can compute these dot products without actually having to transform the data i.e. find some <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>K</mi><annotation encoding="application/x-tex">K</annotation></semantics></math> such that <math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>ϕ</mi><mo stretchy="false" form="prefix">(</mo><msub><mstyle mathvariant="bold"><mi>𝐱</mi></mstyle><mi>i</mi></msub><mo stretchy="false" form="postfix">)</mo><mo>⋅</mo><mi>ϕ</mi><mo stretchy="false" form="prefix">(</mo><msub><mstyle mathvariant="bold"><mi>𝐱</mi></mstyle><mi>j</mi></msub><mo stretchy="false" form="postfix">)</mo><mo>=</mo><mi>K</mi><mo stretchy="false" form="prefix">(</mo><msub><mstyle mathvariant="bold"><mi>𝐱</mi></mstyle><mi>i</mi></msub><mo>,</mo><msub><mstyle mathvariant="bold"><mi>𝐱</mi></mstyle><mi>j</mi></msub><mo stretchy="false" form="postfix">)</mo><mi>.</mi></mrow><annotation encoding="application/x-tex">\phi(\mathbf{x}_i)\cdot \phi(\mathbf{x}_j)= K(\mathbf{x}_i, \mathbf{x}_j).</annotation></semantics></math></p>
<p>Mercer’s theorem allows us to do exactly this, but in the other direction - if we choose <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>K</mi><annotation encoding="application/x-tex">K</annotation></semantics></math> so that the associated integral operator <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mstyle mathvariant="bold"><mi>𝐊</mi></mstyle><annotation encoding="application/x-tex">\mathbf{K}</annotation></semantics></math> is positive definite, then we can write <math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>K</mi><mo stretchy="false" form="prefix">(</mo><msub><mstyle mathvariant="bold"><mi>𝐱</mi></mstyle><mi>i</mi></msub><mo>,</mo><msub><mstyle mathvariant="bold"><mi>𝐱</mi></mstyle><mi>j</mi></msub><mo stretchy="false" form="postfix">)</mo><mo>=</mo><munderover><mo>∑</mo><mrow><mi>j</mi><mo>=</mo><mn>1</mn></mrow><mi>∞</mi></munderover><msub><mi>κ</mi><mi>j</mi></msub><msub><mi>e</mi><mi>j</mi></msub><mo stretchy="false" form="prefix">(</mo><mi>s</mi><mo stretchy="false" form="postfix">)</mo><msub><mi>e</mi><mi>j</mi></msub><mo stretchy="false" form="prefix">(</mo><mi>t</mi><mo stretchy="false" form="postfix">)</mo><mo>=</mo><mo stretchy="false" form="prefix">⟨</mo><mi>ϕ</mi><mo stretchy="false" form="prefix">(</mo><msub><mstyle mathvariant="bold"><mi>𝐱</mi></mstyle><mi>i</mi></msub><mo stretchy="false" form="postfix">)</mo><mo>,</mo><mi>ϕ</mi><mo stretchy="false" form="prefix">(</mo><msub><mstyle mathvariant="bold"><mi>𝐱</mi></mstyle><mi>j</mi></msub><mo stretchy="false" form="postfix">)</mo><mo stretchy="false" form="postfix">⟩</mo><mo>,</mo></mrow><annotation encoding="application/x-tex">K(\mathbf{x}_i, \mathbf{x}_j)=\sum_{j=1}^{\infty} \kappa_j e_j(s) e_j(t)= \langle \phi(\mathbf{x}_i), \phi(\mathbf{x}_j)\rangle,</annotation></semantics></math> where <math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>ϕ</mi><mo>:</mo><mrow><mo stretchy="true" form="prefix">[</mo><mtable><mtr><mtd columnalign="center"><msub><mi>x</mi><mn>1</mn></msub></mtd><mtd columnalign="center"><msub><mi>x</mi><mn>2</mn></msub></mtd><mtd columnalign="center"><mi>⋯</mi></mtd></mtr></mtable><mo stretchy="true" form="postfix">]</mo></mrow><mo accent="false">↦</mo><mrow><mo stretchy="true" form="prefix">[</mo><mtable><mtr><mtd columnalign="center"><msqrt><msub><mi>κ</mi><mn>1</mn></msub></msqrt><msub><mi>e</mi><mi>j</mi></msub><mo stretchy="false" form="prefix">(</mo><msub><mi>x</mi><mn>1</mn></msub><mo stretchy="false" form="postfix">)</mo></mtd><mtd columnalign="center"><msqrt><msub><mi>κ</mi><mn>1</mn></msub></msqrt><msub><mi>e</mi><mi>j</mi></msub><mo stretchy="false" form="prefix">(</mo><msub><mi>x</mi><mn>2</mn></msub><mo stretchy="false" form="postfix">)</mo></mtd><mtd columnalign="center"><mi>⋯</mi></mtd></mtr></mtable><mo stretchy="true" form="postfix">]</mo></mrow><mi>.</mi></mrow><annotation encoding="application/x-tex">\phi: \left[\begin{array}{ccc} x_1&amp; x_2&amp;\cdots \end{array}\right]\mapsto \left[\begin{array}{ccc} \sqrt{\kappa_1} e_j(x_1)&amp; \sqrt{\kappa_1} e_j(x_2)&amp;\cdots \end{array}\right].</annotation></semantics></math></p>
<p>So instead of trying to choose <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>ϕ</mi><annotation encoding="application/x-tex">\phi</annotation></semantics></math> so that <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>K</mi><annotation encoding="application/x-tex">K</annotation></semantics></math> exists, we just choose an appropriate <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>K</mi><annotation encoding="application/x-tex">K</annotation></semantics></math>, and don’t even need to think about <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>ϕ</mi><annotation encoding="application/x-tex">\phi</annotation></semantics></math>.</p>
</body>
</html>

  
  </article>

  </div>
  <div class="thefooter">
    <p>Made with Athena
    <br><br>Copyright, <i>2016</i></p>
  </div> <!-- footer end -->
</body>
</html>