<!DOCTYPE html>
<head>
  <meta charset="utf-8"/>
  <title>Multiple Testing Procedures &mdash; Patterns of Ideas</title>
  <link rel="stylesheet" type="text/css" href="/static/tufte.css">
  <link rel="stylesheet" type="text/css" href="/static/latex.min.css">
  <link rel="stylesheet" type="text/css" href="/static/pygments.min.css">
  <script type="text/javascript" src="/static/enquire.min.js"></script>
  <script type="text/javascript" src="/static/jquery-1.12.4.min.js"></script>
  <script type="text/javascript" src="/static/resources.min.js"></script>
  <script type="text/javascript" src="/static/LaTeXMathML.min.js"></script>
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <link rel='shortcut icon' href="/static/favicon.ico" type='image/x-icon'/>
  <style type="text/css">
   img { mix-blend-mode: multiply; }
  </style>
  <meta property="og:author" content="Samir Khan" />
  <meta property="og:title" content="Multiple Testing Procedures" />
  <meta property="og:type" content="website" />
  <meta property="og:description" content="Notes on the multiple testing problem." />
  <meta property="og:url" content="/posts/hypothesis/" />
  <meta property="og:image" content="/static/img/athena.png" />
  <meta name="twitter:card" content="summary" />
  <meta name="twitter:title" content="Multiple Testing Procedures" />
  <meta name="twitter:description" content="Notes on the multiple testing problem." />
  <meta name="twitter:url" content="/posts/hypothesis/" />
  <meta name="twitter:image" content="/static/img/athena.png" />
  <script src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML" type="text/javascript"></script>
</head>
<body>
  <div class="thearticle">

  <article>
  
    <h1>Multiple Testing Procedures</h1>
    <p id="blog-p"><span id="blogdesc" class="marginnote">
    A personal blog by Samir Khan<br><br>
    <a href="/">home</a> ·
    
      <a href="/about/">
        about</a>
    </span></p>

    <subtitle class="sub-date">March 19, 2017 · <span style="font-size: 1.6rem;"><a style="border-bottom-width: 0px !important;" href="/posts/hypothesis/">&infin;</a></span></subtitle>

    <!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
  <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
  <meta http-equiv="Content-Style-Type" content="text/css" />
  <meta name="generator" content="pandoc" />
  <title></title>
  <style type="text/css">code{white-space: pre;}</style>
</head>
<body>
<p>Here’s something problematic: let’s say you run a hypothesis test at a significance level of <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>α</mi><mo>=</mo><mn>0.05</mn></mrow><annotation encoding="application/x-tex">\alpha=0.05</annotation></semantics></math>. Then, assuming you ran the test correctly and met assumptions, the probability of a type I error is only 5%. But if you instead run 100 tests at a significance level of <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>α</mi><mo>=</mo><mn>0.05</mn></mrow><annotation encoding="application/x-tex">\alpha=0.05</annotation></semantics></math>, the probability of making at least one type I error soars to <math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>1</mn><mo>−</mo><mo stretchy="false" form="prefix">(</mo><mn>1</mn><mo>−</mo><mn>0.05</mn><msup><mo stretchy="false" form="postfix">)</mo><mn>100</mn></msup><mo>≈</mo><mn>99</mn><mi>%</mi><mo>,</mo></mrow><annotation encoding="application/x-tex">1-(1-0.05)^{100}\approx 99\%,</annotation></semantics></math> and this only gets worse as you run increasingly many tests. This is the multiple testing problem, and this blog post discusses a couple of solutions to it as well as why they work. Most of this is taken from my notes for UChicago’s STAT 278, which I’d highly recommend to anyone interested in these sorts of things.</p>
<p>The set up for the rest of this post is as follows. We have p-values <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>p</mi><mn>1</mn></msub><mo>,</mo><mi>⋯</mi><mo>,</mo><msub><mi>p</mi><mi>n</mi></msub></mrow><annotation encoding="application/x-tex">p_1,\cdots, p_n</annotation></semantics></math> that we’ve acquired from some hypothesis tests. Some of these come from true null hypotheses, and are distributed uniformly on <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false" form="prefix">[</mo><mn>0</mn><mo>,</mo><mn>1</mn><mo stretchy="false" form="postfix">]</mo></mrow><annotation encoding="application/x-tex">[0,1]</annotation></semantics></math>. The rest come from false null hypotheses, and we know nothing about their distribution.</p>
<p>We want to run a test that will have a significance level of <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>α</mi><annotation encoding="application/x-tex">\alpha</annotation></semantics></math>, not for each test individually, but for all of them together. This will turn out to mean different things for different methods.</p>
<h2 id="bonferroni-correction">1. Bonferroni Correction</h2>
<p>This is a method for testing the <em>global</em> null hypothesis, which is the hypothesis that all of the null hypotheses that generated our p-values are true (so we take the intersection of the relevant events). We do this in the most naive way possible, and it turns out to work.</p>
<p>We just test each of the <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msub><mi>p</mi><mi>i</mi></msub><annotation encoding="application/x-tex">p_i</annotation></semantics></math> at a significance level of <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>α</mi><mi>/</mi><mi>n</mi></mrow><annotation encoding="application/x-tex">\alpha/n</annotation></semantics></math>, and reject the global null if any of the <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msub><mi>p</mi><mi>i</mi></msub><annotation encoding="application/x-tex">p_i</annotation></semantics></math> are rejected. That is, we reject the global null if <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>p</mi><mi>i</mi></msub><mo>≤</mo><mi>α</mi><mi>/</mi><mi>n</mi></mrow><annotation encoding="application/x-tex">p_i\leq \alpha/n</annotation></semantics></math> for some <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>i</mi><annotation encoding="application/x-tex">i</annotation></semantics></math> and fail to reject otherwise.</p>
<p>In what sense does this work?</p>
<p><strong>Proposition 1.</strong> <em>When testing the global null hypothesis using Bonferroni correction, the probability of making a type I error is <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>≤</mo><mi>α</mi></mrow><annotation encoding="application/x-tex">\leq\alpha</annotation></semantics></math>.</em></p>
<p><em>Proof.</em> This is direct. The probability that we reject the global null is <math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mstyle mathvariant="double-struck"><mi>ℙ</mi></mstyle><mrow><mo stretchy="true" form="prefix">(</mo><munder><mo>min</mo><mrow><mn>1</mn><mo>≤</mo><mi>i</mi><mo>≤</mo><mi>n</mi></mrow></munder><msub><mi>p</mi><mi>i</mi></msub><mo>≤</mo><mfrac><mi>α</mi><mi>n</mi></mfrac><mo stretchy="true" form="postfix">)</mo></mrow><mo>=</mo><mstyle mathvariant="double-struck"><mi>ℙ</mi></mstyle><mrow><mo stretchy="true" form="prefix">(</mo><munderover><mo>⋃</mo><mrow><mi>i</mi><mo>=</mo><mn>1</mn></mrow><mi>n</mi></munderover><mrow><mo stretchy="true" form="prefix">{</mo><msub><mi>p</mi><mi>i</mi></msub><mo>≤</mo><mfrac><mi>α</mi><mi>n</mi></mfrac><mo stretchy="true" form="postfix">}</mo></mrow><mo stretchy="true" form="postfix">)</mo></mrow><mo>,</mo></mrow><annotation encoding="application/x-tex">\mathbb{P}\left(\min_{1\leq i\leq n} p_i\leq \frac{\alpha}{n}\right)=\mathbb{P}\left(\bigcup_{i=1}^n \left\{p_i\leq \frac{\alpha}{n}\right\}\right),</annotation></semantics></math> which by the union bound is <math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>≤</mo><munderover><mo>∑</mo><mrow><mi>i</mi><mo>=</mo><mn>1</mn></mrow><mi>n</mi></munderover><mstyle mathvariant="double-struck"><mi>ℙ</mi></mstyle><mrow><mo stretchy="true" form="prefix">(</mo><msub><mi>p</mi><mi>i</mi></msub><mo>≤</mo><mfrac><mi>α</mi><mi>n</mi></mfrac><mo stretchy="true" form="postfix">)</mo></mrow><mo>=</mo><mi>n</mi><mo>⋅</mo><mfrac><mi>α</mi><mi>n</mi></mfrac><mo>=</mo><mi>α</mi><mo>,</mo></mrow><annotation encoding="application/x-tex">\leq \sum_{i=1}^n\mathbb{P}\left(p_i\leq \frac{\alpha}{n}\right)=n\cdot \frac{\alpha}{n}=\alpha,</annotation></semantics></math> so we have FWER control. <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>◼</mi><annotation encoding="application/x-tex">\blacksquare</annotation></semantics></math></p>
<p>So that’s nice. But it’s also extremely conservative, and we can afford to do things that are a bit more powerful.</p>
<h2 id="simes-test">2. Simes’ Test</h2>
<p>Here we’re also testing the global null, but a bit more cleverly. The Simes’ test rejects the global null if there is 1 p-value that is <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>≤</mo><mfrac><mi>α</mi><mi>n</mi></mfrac></mrow><annotation encoding="application/x-tex">\leq \frac{\alpha}{n}</annotation></semantics></math>, or 2 p-values that are <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>≤</mo><mfrac><mrow><mn>2</mn><mi>α</mi></mrow><mi>n</mi></mfrac></mrow><annotation encoding="application/x-tex">\leq \frac{2\alpha}{n}</annotation></semantics></math>, or in general, if there are <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>k</mi><annotation encoding="application/x-tex">k</annotation></semantics></math> p-values that are <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>≤</mo><mfrac><mrow><mi>k</mi><mi>α</mi></mrow><mi>n</mi></mfrac></mrow><annotation encoding="application/x-tex">\leq \frac{k\alpha}{n}</annotation></semantics></math> for any <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>1</mn><mo>≤</mo><mi>k</mi><mo>≤</mo><mi>n</mi></mrow><annotation encoding="application/x-tex">1\leq k\leq n</annotation></semantics></math>. This will reject when Bonferroni rejects, but also in some other cases, so its more powerful. This power costs something, though: we need an assumption of independence to get a bound, and this bound isn’t as strong as for Bonferroni.</p>
<p><strong>Proposition 2.</strong> <em>If the p-values are independent, then when testing the global null hypothesis using Simes’ test, the probability of making a type I error is <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>≤</mo><mi>α</mi><msub><mi>H</mi><mi>n</mi></msub><mo>≈</mo><mi>α</mi><mo>log</mo><mi>n</mi></mrow><annotation encoding="application/x-tex">\leq\alpha H_n\approx \alpha \log n</annotation></semantics></math>.</em></p>
<p>We assign a score to each <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>p</mi><annotation encoding="application/x-tex">p</annotation></semantics></math>-value that measures what percent of the way it gets us to rejecting the global null. Let <math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>s</mi><mi>i</mi></msub><mo>=</mo><mn>1</mn><mrow><mspace width="0.333em"></mspace><mtext mathvariant="normal"> if </mtext><mspace width="0.333em"></mspace></mrow><msub><mi>p</mi><mi>i</mi></msub><mo>≤</mo><mfrac><mi>α</mi><mi>n</mi></mfrac><mo>,</mo><mspace width="1.0em"></mspace><msub><mi>s</mi><mi>i</mi></msub><mo>=</mo><mfrac><mn>1</mn><mn>2</mn></mfrac><mrow><mspace width="0.333em"></mspace><mtext mathvariant="normal"> if </mtext><mspace width="0.333em"></mspace></mrow><mfrac><mi>α</mi><mi>n</mi></mfrac><mo>≤</mo><msub><mi>p</mi><mi>i</mi></msub><mo>≤</mo><mfrac><mrow><mn>2</mn><mi>α</mi></mrow><mi>n</mi></mfrac></mrow><annotation encoding="application/x-tex">s_i = 1\text{ if } p_i\leq \frac{\alpha}{n},\quad s_i=\frac{1}{2}\text{ if } \frac{\alpha}{n}\leq p_i\leq \frac{2\alpha}{n}</annotation></semantics></math> and so on up to <math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>s</mi><mi>i</mi></msub><mo>=</mo><mfrac><mn>1</mn><mi>n</mi></mfrac><mrow><mspace width="0.333em"></mspace><mtext mathvariant="normal"> if </mtext><mspace width="0.333em"></mspace></mrow><mfrac><mrow><mi>α</mi><mo stretchy="false" form="prefix">(</mo><mi>n</mi><mo>−</mo><mn>1</mn><mo stretchy="false" form="postfix">)</mo></mrow><mi>n</mi></mfrac><mo>≤</mo><msub><mi>p</mi><mi>i</mi></msub><mo>≤</mo><mi>α</mi><mo>,</mo><mspace width="1.0em"></mspace><msub><mi>s</mi><mi>i</mi></msub><mo>=</mo><mn>0</mn><mrow><mspace width="0.333em"></mspace><mtext mathvariant="normal"> if </mtext><mspace width="0.333em"></mspace></mrow><msub><mi>p</mi><mi>i</mi></msub><mo>&gt;</mo><mi>α</mi><mi>.</mi></mrow><annotation encoding="application/x-tex">s_i = \frac{1}{n}\text{ if } \frac{\alpha(n-1)}{n}\leq p_i\leq \alpha,\quad s_i=0\text{ if } p_i&gt;\alpha.</annotation></semantics></math></p>
<p>Then, Simes rejects if and only if, for some <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>k</mi><annotation encoding="application/x-tex">k</annotation></semantics></math>, there are <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>k</mi><annotation encoding="application/x-tex">k</annotation></semantics></math> <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msub><mi>p</mi><mi>i</mi></msub><annotation encoding="application/x-tex">p_i</annotation></semantics></math>’s that are <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>≤</mo><mfrac><mrow><mi>k</mi><mi>α</mi></mrow><mi>n</mi></mfrac></mrow><annotation encoding="application/x-tex">\leq \frac{k\alpha }{n}</annotation></semantics></math>, which means that the sum of the <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msub><mi>s</mi><mi>i</mi></msub><annotation encoding="application/x-tex">s_i</annotation></semantics></math> is <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>≥</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">\geq 1</annotation></semantics></math>. So now we can calculate the probability of that happening.</p>
<p>The expected value of any given score is <math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mstyle mathvariant="double-struck"><mi>𝔼</mi></mstyle><mo stretchy="false" form="prefix">[</mo><msub><mi>s</mi><mi>i</mi></msub><mo stretchy="false" form="postfix">]</mo><mo>=</mo><mn>1</mn><mo>⋅</mo><mfrac><mi>α</mi><mi>n</mi></mfrac><mo>+</mo><mi>⋯</mi><mo>+</mo><mfrac><mn>1</mn><mi>n</mi></mfrac><mo>⋅</mo><mfrac><mi>α</mi><mi>n</mi></mfrac><mo>=</mo><mfrac><mi>α</mi><mi>n</mi></mfrac><msub><mi>H</mi><mi>n</mi></msub><mi>.</mi></mrow><annotation encoding="application/x-tex">\mathbb{E}[s_i]=1\cdot \frac{\alpha}{n}+\cdots +\frac{1}{n}\cdot \frac{\alpha}{n}=\frac{\alpha}{n}H_n.</annotation></semantics></math> Then, <math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mstyle mathvariant="double-struck"><mi>ℙ</mi></mstyle><mo stretchy="false" form="prefix">(</mo><mtext mathvariant="normal">Simes rejects</mtext><mo stretchy="false" form="postfix">)</mo><mo>≤</mo><mstyle mathvariant="double-struck"><mi>ℙ</mi></mstyle><mrow><mo stretchy="true" form="prefix">(</mo><munderover><mo>∑</mo><mrow><mi>i</mi><mo>=</mo><mn>1</mn></mrow><mi>m</mi></munderover><msub><mi>s</mi><mi>i</mi></msub><mo>≥</mo><mn>1</mn><mo stretchy="true" form="postfix">)</mo></mrow><mo>≤</mo><mstyle mathvariant="double-struck"><mi>𝔼</mi></mstyle><mrow><mo stretchy="true" form="prefix">[</mo><munderover><mo>∑</mo><mrow><mi>i</mi><mo>=</mo><mn>1</mn></mrow><mi>n</mi></munderover><msub><mi>s</mi><mi>i</mi></msub><mo stretchy="true" form="postfix">]</mo></mrow><mo>=</mo><mi>n</mi><mo>⋅</mo><mfrac><mi>α</mi><mi>n</mi></mfrac><msub><mi>H</mi><mi>n</mi></msub><mo>=</mo><mi>α</mi><msub><mi>H</mi><mi>n</mi></msub><mi>.</mi><mi>◼</mi></mrow><annotation encoding="application/x-tex">\mathbb{P}(\text{Simes rejects})\leq \mathbb{P}\left(\sum_{i=1}^m s_i\geq 1\right)\leq \mathbb{E}\left[\sum_{i=1}^n s_i\right] =n\cdot \frac{\alpha}{n}H_n =\alpha H_n.\blacksquare</annotation></semantics></math></p>
<p>Note that for large <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>n</mi><annotation encoding="application/x-tex">n</annotation></semantics></math>, the <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>log</mo><mi>n</mi></mrow><annotation encoding="application/x-tex">\log n</annotation></semantics></math> factor counts a lot, and the bound is sharp. The equality construction is a bit of a pain, but the idea is to choose the joint distribution of the <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msub><mi>p</mi><mi>i</mi></msub><annotation encoding="application/x-tex">p_i</annotation></semantics></math> to make them negatively dependent.</p>
<h2 id="holm-bonferroni">3. Holm-Bonferroni</h2>
<p>This test is different from the previous two in that it does not test the global null, but instead individually tests each of the <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msub><mi>p</mi><mi>i</mi></msub><annotation encoding="application/x-tex">p_i</annotation></semantics></math> and then controls the family-wise error rate (FWER), which is the probability of making at least one type I error across all the p-values. As an added bonus, we can accept/reject individual p-values rather than accepting/rejecting them all at once, so we have a much better sense of how significant the results are, taken together.</p>
<p>The idea of Holm-Bonferroni is to run Bonferroni until acceptance. We first run Bonferroni on <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>p</mi><mn>1</mn></msub><mo>,</mo><mi>⋯</mi><mo>,</mo><msub><mi>p</mi><mi>n</mi></msub></mrow><annotation encoding="application/x-tex">p_1,\cdots, p_n</annotation></semantics></math>. If we do not reject the global null, we stop. If we do, then we reject the smallest p-value, and repeat this procedure with the other p-values, continuing until we do not reject the global null.</p>
<p>Equivalently, if we order the p-values as <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>p</mi><mrow><mo stretchy="false" form="prefix">(</mo><mn>1</mn><mo stretchy="false" form="postfix">)</mo></mrow></msub><mo>,</mo><mi>⋯</mi><mo>,</mo><msub><mi>p</mi><mrow><mo stretchy="false" form="prefix">(</mo><mi>n</mi><mo stretchy="false" form="postfix">)</mo></mrow></msub></mrow><annotation encoding="application/x-tex">p_{(1)},\cdots, p_{(n)}</annotation></semantics></math>, this is the same as checking if <math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>p</mi><mrow><mo stretchy="false" form="prefix">(</mo><mi>k</mi><mo stretchy="false" form="postfix">)</mo></mrow></msub><mo>≤</mo><mfrac><mi>α</mi><mrow><mi>n</mi><mo>+</mo><mi>k</mi><mo>−</mo><mn>1</mn></mrow></mfrac></mrow><annotation encoding="application/x-tex">p_{(k)}\leq \frac{\alpha}{n+k-1}</annotation></semantics></math> for each <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>k</mi><mo>=</mo><mn>1</mn><mo>,</mo><mi>⋯</mi><mo>,</mo><mi>n</mi></mrow><annotation encoding="application/x-tex">k=1,\cdots, n</annotation></semantics></math> and rejecting all the p-values before the first <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>k</mi><annotation encoding="application/x-tex">k</annotation></semantics></math> that fails this test.</p>
<p><strong>Proposition 3.</strong> <em>For Holm-Bonferroni, we have <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mtext mathvariant="normal">FWER</mtext><mo>≤</mo><mi>α</mi></mrow><annotation encoding="application/x-tex">\text{FWER}\leq \alpha</annotation></semantics></math>.</em></p>
<p>Let <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>n</mi><mn>0</mn></msub><mo>=</mo><mi>#</mi><mrow><mspace width="0.333em"></mspace><mtext mathvariant="normal"> of nulls</mtext></mrow></mrow><annotation encoding="application/x-tex">n_0=\#\text{ of nulls}</annotation></semantics></math>. Then <math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mstyle mathvariant="double-struck"><mi>ℙ</mi></mstyle><mrow><mo stretchy="true" form="prefix">(</mo><munder><mo>min</mo><mrow><mrow><mtext mathvariant="normal">nulls </mtext><mspace width="0.333em"></mspace></mrow><mi>i</mi></mrow></munder><mo>≤</mo><mfrac><mi>α</mi><msub><mi>n</mi><mn>0</mn></msub></mfrac><mo stretchy="true" form="postfix">)</mo></mrow><mo>≤</mo><mi>α</mi><mo>,</mo></mrow><annotation encoding="application/x-tex">\mathbb{P}\left(\min_{\text{nulls }i} \leq \frac{\alpha}{n_0}\right)\leq \alpha,</annotation></semantics></math> from a union bound. In this case, we might have false rejections, but this only happens <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>α</mi><annotation encoding="application/x-tex">\alpha</annotation></semantics></math> of the time. So we show that the other <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>1</mn><mo>−</mo><mi>α</mi></mrow><annotation encoding="application/x-tex">1-\alpha</annotation></semantics></math> of the time, there are no false rejections.</p>
<p>Suppose <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>p</mi><mi>i</mi></msub><mo>&gt;</mo><mfrac><mi>α</mi><msub><mi>n</mi><mn>0</mn></msub></mfrac></mrow><annotation encoding="application/x-tex">p_i&gt;\frac{\alpha}{n_0}</annotation></semantics></math> for all nulls <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>i</mi><annotation encoding="application/x-tex">i</annotation></semantics></math>. Then, take the ordered <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>p</mi><annotation encoding="application/x-tex">p</annotation></semantics></math>-values <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>p</mi><mrow><mo stretchy="false" form="prefix">(</mo><mn>1</mn><mo stretchy="false" form="postfix">)</mo></mrow></msub><mo>,</mo><mi>⋯</mi><mo>,</mo><msub><mi>p</mi><mrow><mo stretchy="false" form="prefix">(</mo><mi>n</mi><mo stretchy="false" form="postfix">)</mo></mrow></msub></mrow><annotation encoding="application/x-tex">p_{(1)},\cdots, p_{(n)}</annotation></semantics></math>. Let <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msub><mi>p</mi><mrow><mo stretchy="false" form="prefix">(</mo><mi>k</mi><mo stretchy="false" form="postfix">)</mo></mrow></msub><annotation encoding="application/x-tex">p_{(k)}</annotation></semantics></math> be the first <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>p</mi><annotation encoding="application/x-tex">p</annotation></semantics></math>-value that comes from a null. We know that this <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>p</mi><annotation encoding="application/x-tex">p</annotation></semantics></math>-value can’t be too small, and we know it can’t happen super late in the list, because there are at most <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi><mo>−</mo><msub><mi>n</mi><mn>0</mn></msub></mrow><annotation encoding="application/x-tex">n-n_0</annotation></semantics></math> non-nulls. This means that <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>k</mi><mo>≤</mo><mi>n</mi><mo>−</mo><msub><mi>n</mi><mn>0</mn></msub><mo>+</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">k\leq n-n_0+1</annotation></semantics></math>. There are two cases now: the procedure stops before step <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>k</mi><annotation encoding="application/x-tex">k</annotation></semantics></math> (which means no false rejections because no nulls before <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>k</mi><annotation encoding="application/x-tex">k</annotation></semantics></math>). Or, it gets to step <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>k</mi><annotation encoding="application/x-tex">k</annotation></semantics></math>, and we check if <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>p</mi><mrow><mo stretchy="false" form="prefix">(</mo><mi>k</mi><mo stretchy="false" form="postfix">)</mo></mrow></msub><mo>≤</mo><mfrac><mi>α</mi><mrow><mi>n</mi><mo>+</mo><mn>1</mn><mo>−</mo><mi>k</mi></mrow></mfrac></mrow><annotation encoding="application/x-tex">p_{(k)}\leq \frac{\alpha}{n+1-k}</annotation></semantics></math>. But we know that <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>p</mi><mrow><mo stretchy="false" form="prefix">(</mo><mi>k</mi><mo stretchy="false" form="postfix">)</mo></mrow></msub><mo>&gt;</mo><mfrac><mi>α</mi><msub><mi>n</mi><mn>0</mn></msub></mfrac></mrow><annotation encoding="application/x-tex">p_{(k)}&gt;\frac{\alpha}{n_0}</annotation></semantics></math> and <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>k</mi><mo>≤</mo><mi>n</mi><mo>−</mo><msub><mi>n</mi><mn>0</mn></msub><mo>+</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">k\leq n-n_0+1</annotation></semantics></math>, so the <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mfrac><mi>α</mi><mrow><mi>n</mi><mo>+</mo><mn>1</mn><mo>−</mo><mi>k</mi></mrow></mfrac><mo>≤</mo><mfrac><mi>α</mi><msub><mi>n</mi><mn>0</mn></msub></mfrac></mrow><annotation encoding="application/x-tex">\frac{\alpha}{n+1-k}\leq \frac{\alpha}{n_0}</annotation></semantics></math>. By our assumption on the null <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msub><mi>p</mi><mi>i</mi></msub><annotation encoding="application/x-tex">p_i</annotation></semantics></math> then, we stop at step <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>k</mi><annotation encoding="application/x-tex">k</annotation></semantics></math>, and there are no false rejections. <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>◼</mi><annotation encoding="application/x-tex">\blacksquare</annotation></semantics></math></p>
<p>As with the Bonferroni correction, we don’t need any assumptions of independence.</p>
<h2 id="benjamini-hochberg">4. Benjamini-Hochberg</h2>
<p>This is another multiple testing procedure, but instead of controlling the FWER, it controls <math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mtext mathvariant="normal">FDR</mtext><mo>=</mo><mstyle mathvariant="double-struck"><mi>𝔼</mi></mstyle><mrow><mo stretchy="true" form="prefix">[</mo><mfrac><mrow><mi>#</mi><mrow><mspace width="0.333em"></mspace><mtext mathvariant="normal"> null p-values rejected</mtext></mrow></mrow><mrow><mi>#</mi><mrow><mspace width="0.333em"></mspace><mtext mathvariant="normal"> p-values rejected</mtext></mrow></mrow></mfrac><mo stretchy="true" form="postfix">]</mo></mrow><mo>,</mo></mrow><annotation encoding="application/x-tex">\text{FDR}=\mathbb{E}\left[\frac{\#\text{ null p-values rejected}}{\#\text{ p-values rejected}}\right],</annotation></semantics></math> the false discovery rate. The quantity we’re taking the expectation of is the false discovery proportion (FDP).</p>
<p>Here, we build on Simes’ test by running Simes’, and then rejecting those <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>k</mi><annotation encoding="application/x-tex">k</annotation></semantics></math> p-values that are <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>≤</mo><mi>α</mi><mfrac><mi>k</mi><mi>n</mi></mfrac></mrow><annotation encoding="application/x-tex">\leq \alpha\frac{k}{n}</annotation></semantics></math>, for the maximum <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>k</mi><annotation encoding="application/x-tex">k</annotation></semantics></math> we can do this for. Equivalently, we choose some threshold <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>α</mi><mfrac><mi>k</mi><mi>n</mi></mfrac></mrow><annotation encoding="application/x-tex">\alpha\frac{k}{n}</annotation></semantics></math>, and then reject all the p-values below this threshold.</p>
<p><strong>Proposition 4.</strong> <em>If the p-values are independent, the Benjamin-Hochberg gives <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mtext mathvariant="normal">FDR</mtext><mo>=</mo><mi>α</mi><mfrac><msub><mi>n</mi><mn>0</mn></msub><mi>n</mi></mfrac><mo>≤</mo><mi>α</mi></mrow><annotation encoding="application/x-tex">\text{FDR}=\alpha\frac{n_0}{n}\leq \alpha</annotation></semantics></math>.</em></p>
<p><em>Proof.</em> Suppose we make <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mover><mi>k</mi><mo accent="true">^</mo></mover><annotation encoding="application/x-tex">\hat{k}</annotation></semantics></math> rejections, so our threshold is <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>α</mi><mfrac><mover><mi>k</mi><mo accent="true">^</mo></mover><mi>n</mi></mfrac></mrow><annotation encoding="application/x-tex">\alpha\frac{\hat{k}}{n}</annotation></semantics></math>, meaning that <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msub><mi>p</mi><mi>i</mi></msub><annotation encoding="application/x-tex">p_i</annotation></semantics></math> is rejected iff <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>p</mi><mi>i</mi></msub><mo>≤</mo><mi>α</mi><mfrac><mover><mi>k</mi><mo accent="true">^</mo></mover><mi>n</mi></mfrac></mrow><annotation encoding="application/x-tex">p_i\leq \alpha\frac{\hat{k}}{n}</annotation></semantics></math>. The trouble is that here, the RHS also depends on <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msub><mi>p</mi><mi>i</mi></msub><annotation encoding="application/x-tex">p_i</annotation></semantics></math>, so we have to go through some gymnastics to get around this.</p>
<p>Let <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msub><mover><mi>k</mi><mo accent="true">^</mo></mover><mi>i</mi></msub><annotation encoding="application/x-tex">\hat{k}_i</annotation></semantics></math> be the largest <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>k</mi><annotation encoding="application/x-tex">k</annotation></semantics></math> such that there are <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>k</mi><mo>−</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">k-1</annotation></semantics></math> many p-values <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msub><mi>p</mi><mi>j</mi></msub><annotation encoding="application/x-tex">p_j</annotation></semantics></math> with <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>j</mi><mo>≠</mo><mi>i</mi></mrow><annotation encoding="application/x-tex">j\neq i</annotation></semantics></math> that are <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>≤</mo><mi>α</mi><mfrac><mi>k</mi><mi>n</mi></mfrac></mrow><annotation encoding="application/x-tex">\leq \alpha\frac{k}{n}</annotation></semantics></math>. Call this statement the <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msub><mtext mathvariant="normal">BH</mtext><mi>i</mi></msub><annotation encoding="application/x-tex">\text{BH}_i</annotation></semantics></math> statement, and the statement that there are <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>k</mi><annotation encoding="application/x-tex">k</annotation></semantics></math> many p-values <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>≤</mo><mi>α</mi><mfrac><mi>k</mi><mi>n</mi></mfrac></mrow><annotation encoding="application/x-tex">\leq \alpha\frac{k}{n}</annotation></semantics></math> the BH statement.<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>◼</mi><annotation encoding="application/x-tex">\blacksquare</annotation></semantics></math></p>
<p><em>Claim.</em> If <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msub><mi>p</mi><mi>i</mi></msub><annotation encoding="application/x-tex">p_i</annotation></semantics></math> is rejected, then <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mover><mi>k</mi><mo accent="true">^</mo></mover><mo>=</mo><msub><mover><mi>k</mi><mo accent="true">^</mo></mover><mi>i</mi></msub></mrow><annotation encoding="application/x-tex">\hat{k}=\hat{k}_i</annotation></semantics></math>.</p>
<p>Call the first statement the BH statement, and the second one (with <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>k</mi><mo>−</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">k-1</annotation></semantics></math>) the BH<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msub><mi></mi><mtext mathvariant="normal">i</mtext></msub><annotation encoding="application/x-tex">_\text{i}</annotation></semantics></math> statement.</p>
<p>Now, suppose <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msub><mi>p</mi><mi>i</mi></msub><annotation encoding="application/x-tex">p_i</annotation></semantics></math> is rejected. Then <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>p</mi><mi>i</mi></msub><mo>≤</mo><mi>α</mi><mfrac><mi>k</mi><mi>n</mi></mfrac><mo>,</mo></mrow><annotation encoding="application/x-tex">p_i \leq \alpha \frac{k}{n},</annotation></semantics></math> and BH holds for <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>k</mi><mo>=</mo><mover><mi>k</mi><mo accent="true">^</mo></mover></mrow><annotation encoding="application/x-tex">k=\hat{k}</annotation></semantics></math>, so there are <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mover><mi>k</mi><mo accent="true">^</mo></mover><mo>−</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">\hat{k}-1</annotation></semantics></math> of the <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msub><mi>p</mi><mi>j</mi></msub><annotation encoding="application/x-tex">p_j</annotation></semantics></math>, <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>j</mi><mo>≠</mo><mi>i</mi></mrow><annotation encoding="application/x-tex">j\neq i</annotation></semantics></math>, that are also <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>≤</mo><mi>α</mi><mfrac><mover><mi>k</mi><mo accent="true">^</mo></mover><mi>n</mi></mfrac></mrow><annotation encoding="application/x-tex">\leq \alpha \frac{\hat{k}}{n}</annotation></semantics></math>. Thus BH<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msub><mi></mi><mtext mathvariant="normal">i</mtext></msub><annotation encoding="application/x-tex">_{\text{i}}</annotation></semantics></math> holds for <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>k</mi><mo>=</mo><mover><mi>k</mi><mo accent="true">^</mo></mover></mrow><annotation encoding="application/x-tex">k=\hat{k}</annotation></semantics></math>, and so <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mover><mi>k</mi><mo accent="true">^</mo></mover><mi>i</mi></msub><mo>≥</mo><mover><mi>k</mi><mo accent="true">^</mo></mover></mrow><annotation encoding="application/x-tex">\hat{k}_i\geq \hat{k}</annotation></semantics></math>.</p>
<p>On the other hand, <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>p</mi><mi>i</mi></msub><mo>≤</mo><mi>α</mi><mfrac><mover><mi>k</mi><mo accent="true">^</mo></mover><mi>n</mi></mfrac><mo>≤</mo><mi>α</mi><mfrac><msub><mover><mi>k</mi><mo accent="true">^</mo></mover><mi>i</mi></msub><mi>n</mi></mfrac></mrow><annotation encoding="application/x-tex">p_i\leq \alpha \frac{\hat{k}}{n}\leq \alpha \frac{\hat{k}_i}{n}</annotation></semantics></math>, so BH<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msub><mi></mi><mtext mathvariant="normal">i</mtext></msub><annotation encoding="application/x-tex">_{\text{i}}</annotation></semantics></math> is true at <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>k</mi><mo>=</mo><msub><mover><mi>k</mi><mo accent="true">^</mo></mover><mi>i</mi></msub></mrow><annotation encoding="application/x-tex">k=\hat{k}_i</annotation></semantics></math>, which means there are <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msub><mover><mi>k</mi><mo accent="true">^</mo></mover><mi>i</mi></msub><annotation encoding="application/x-tex">\hat{k}_i</annotation></semantics></math> values that are <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>≤</mo><mi>α</mi><mfrac><msub><mover><mi>k</mi><mo accent="true">^</mo></mover><mi>i</mi></msub><mi>n</mi></mfrac></mrow><annotation encoding="application/x-tex">\leq \alpha \frac{\hat{k}_i}{n}</annotation></semantics></math>, so BH is true at <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>k</mi><mo>=</mo><msub><mover><mi>k</mi><mo accent="true">^</mo></mover><mi>i</mi></msub></mrow><annotation encoding="application/x-tex">k=\hat{k}_i</annotation></semantics></math>, and thus <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mover><mi>k</mi><mo accent="true">^</mo></mover><mo>≥</mo><msub><mover><mi>k</mi><mo accent="true">^</mo></mover><mi>i</mi></msub></mrow><annotation encoding="application/x-tex">\hat{k}\geq \hat{k}_i</annotation></semantics></math>. It follows that <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mover><mi>k</mi><mo accent="true">^</mo></mover><mo>=</mo><msub><mover><mi>k</mi><mo accent="true">^</mo></mover><mi>i</mi></msub></mrow><annotation encoding="application/x-tex">\hat{k}=\hat{k}_i</annotation></semantics></math></p>
<p>With this claim, we can move onto the main result. We have <math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mtext mathvariant="normal">FDR</mtext><mo>=</mo><mstyle mathvariant="double-struck"><mi>𝔼</mi></mstyle><mo stretchy="false" form="prefix">[</mo><mtext mathvariant="normal">FDP</mtext><mo stretchy="false" form="postfix">]</mo><mo>=</mo><mstyle mathvariant="double-struck"><mi>𝔼</mi></mstyle><mrow><mo stretchy="true" form="prefix">[</mo><mfrac><mrow><munder><mo>∑</mo><mrow><mi>i</mi><mrow><mspace width="0.333em"></mspace><mtext mathvariant="normal"> null</mtext></mrow></mrow></munder><mstyle mathvariant="bold"><mn>1</mn></mstyle><mo stretchy="false" form="prefix">{</mo><msub><mi>p</mi><mi>i</mi></msub><mrow><mspace width="0.333em"></mspace><mtext mathvariant="normal"> is rejected</mtext></mrow><mo stretchy="false" form="postfix">}</mo></mrow><mrow><mo>max</mo><mo stretchy="false" form="prefix">(</mo><mn>1</mn><mo>,</mo><mover><mi>k</mi><mo accent="true">^</mo></mover><mo stretchy="false" form="postfix">)</mo></mrow></mfrac><mo stretchy="true" form="postfix">]</mo></mrow><mo>=</mo><munder><mo>∑</mo><mrow><mi>i</mi><mrow><mspace width="0.333em"></mspace><mtext mathvariant="normal"> null</mtext></mrow></mrow></munder><mstyle mathvariant="double-struck"><mi>𝔼</mi></mstyle><mrow><mo stretchy="true" form="prefix">[</mo><mfrac><mrow><mstyle mathvariant="bold"><mn>1</mn></mstyle><mo stretchy="false" form="prefix">{</mo><msub><mi>p</mi><mi>i</mi></msub><mrow><mspace width="0.333em"></mspace><mtext mathvariant="normal"> is rejected</mtext></mrow></mrow><mrow><mo>max</mo><mo stretchy="false" form="prefix">(</mo><mn>1</mn><mo>,</mo><mover><mi>k</mi><mo accent="true">^</mo></mover><mo stretchy="false" form="postfix">)</mo></mrow></mfrac><mo stretchy="true" form="postfix">]</mo></mrow><mi>.</mi></mrow><annotation encoding="application/x-tex">\text{FDR}=\mathbb{E}[\text{FDP}]=\mathbb{E}\left[\frac{\sum_{i\text{ null}} \mathbf{1}\{p_i\text{ is rejected}\}}{\max(1, \hat{k})}\right]=\sum_{i\text{ null}} \mathbb{E}\left[\frac{\mathbf{1}\{p_i\text{ is rejected}}{\max(1,\hat{k})}\right].</annotation></semantics></math> We can replace the denominator with <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msub><mover><mi>k</mi><mo accent="true">^</mo></mover><mi>i</mi></msub><annotation encoding="application/x-tex">\hat{k}_i</annotation></semantics></math> without changing the sum, because when they differ, the numerator is 0, so it doesn’t matter. Then, this is <math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><munder><mo>∑</mo><mrow><mi>i</mi><mrow><mspace width="0.333em"></mspace><mtext mathvariant="normal"> null</mtext></mrow></mrow></munder><mstyle mathvariant="double-struck"><mi>𝔼</mi></mstyle><mrow><mo stretchy="true" form="prefix">[</mo><mfrac><mrow><mstyle mathvariant="bold"><mn>1</mn></mstyle><mo stretchy="false" form="prefix">{</mo><msub><mi>p</mi><mi>i</mi></msub><mrow><mspace width="0.333em"></mspace><mtext mathvariant="normal"> rejected</mtext></mrow><mo stretchy="false" form="postfix">}</mo></mrow><msub><mover><mi>k</mi><mo accent="true">^</mo></mover><mi>i</mi></msub></mfrac><mo stretchy="true" form="postfix">]</mo></mrow><mo>≤</mo><munder><mo>∑</mo><mrow><mi>i</mi><mrow><mspace width="0.333em"></mspace><mtext mathvariant="normal"> null</mtext></mrow></mrow></munder><mstyle mathvariant="double-struck"><mi>𝔼</mi></mstyle><mrow><mo stretchy="true" form="prefix">[</mo><mfrac><mrow><mstyle mathvariant="bold"><mn>1</mn></mstyle><mo stretchy="false" form="prefix">{</mo><msub><mi>p</mi><mi>i</mi></msub><mo>≤</mo><mi>α</mi><mfrac><msub><mover><mi>k</mi><mo accent="true">^</mo></mover><mi>i</mi></msub><mi>n</mi></mfrac><mo stretchy="false" form="postfix">}</mo></mrow><msub><mover><mi>k</mi><mo accent="true">^</mo></mover><mi>i</mi></msub></mfrac><mo stretchy="true" form="postfix">]</mo></mrow><mi>.</mi></mrow><annotation encoding="application/x-tex">\sum_{i\text{ null}}\mathbb{E}\left[\frac{\mathbf{1}\{p_i\text{ rejected}\}}{\hat{k}_i}\right]\leq \sum_{i\text{ null}}\mathbb{E}\left[\frac{\mathbf{1}\{p_i\leq \alpha \frac{\hat{k}_i}{n}\}}{\hat{k}_i}\right].</annotation></semantics></math> This is an inequality because if the first numerator is 1, the second is definitely 1, but if the first is 0, the second might not be.</p>
<p>Now, we use the tower law to write this as <math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><munder><mo>∑</mo><mrow><mi>i</mi><mrow><mspace width="0.333em"></mspace><mtext mathvariant="normal"> null</mtext></mrow></mrow></munder><mstyle mathvariant="double-struck"><mi>𝔼</mi></mstyle><mrow><mo stretchy="true" form="prefix">[</mo><mstyle mathvariant="double-struck"><mi>𝔼</mi></mstyle><mrow><mo stretchy="true" form="prefix">[</mo><mfrac><mrow><mstyle mathvariant="bold"><mn>1</mn></mstyle><mo stretchy="false" form="prefix">{</mo><msub><mi>p</mi><mi>i</mi></msub><mo>≤</mo><mi>α</mi><mo>⋅</mo><msub><mover><mi>k</mi><mo accent="true">^</mo></mover><mi>i</mi></msub><mi>/</mi><mi>n</mi><mo stretchy="false" form="postfix">}</mo></mrow><msub><mi>k</mi><mi>i</mi></msub></mfrac><mo minsize="1.8" maxsize="1.8" stretchy="false" form="prefix">|</mo><msub><mi>p</mi><mi>j</mi></msub><mo>,</mo><mi>j</mi><mo>≠</mo><mi>i</mi><mo stretchy="true" form="postfix">]</mo></mrow><mo stretchy="true" form="postfix">]</mo></mrow><mi>.</mi></mrow><annotation encoding="application/x-tex">\sum_{i\text{ null}} \mathbb{E}\left[\mathbb{E}\left[\frac{\mathbf{1}\{p_i\leq \alpha\cdot \hat{k}_i/n\}}{k_i}\Big| p_j, j\neq i\right]\right].</annotation></semantics></math> That conditional expectation is just <math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mfrac><mrow><mstyle mathvariant="double-struck"><mi>ℙ</mi></mstyle><mo stretchy="false" form="prefix">{</mo><msub><mi>p</mi><mi>i</mi></msub><mo>≤</mo><mi>α</mi><msub><mover><mi>k</mi><mo accent="true">^</mo></mover><mi>i</mi></msub><mi>/</mi><mi>n</mi><mo>∣</mo><msub><mi>p</mi><mi>j</mi></msub><mo>,</mo><mi>j</mi><mo>≠</mo><mi>i</mi><mo stretchy="false" form="postfix">}</mo></mrow><msub><mover><mi>k</mi><mo accent="true">^</mo></mover><mi>i</mi></msub></mfrac><mo>=</mo><mfrac><mrow><mi>α</mi><msub><mover><mi>k</mi><mo accent="true">^</mo></mover><mi>i</mi></msub><mi>/</mi><mi>n</mi></mrow><msub><mover><mi>k</mi><mo accent="true">^</mo></mover><mi>i</mi></msub></mfrac><mo>=</mo><mi>α</mi><mi>/</mi><mi>n</mi><mi>.</mi></mrow><annotation encoding="application/x-tex">\frac{\mathbb{P}\{p_i\leq \alpha\hat{k}_i/n\mid p_j, j\neq i\}}{\hat{k}_i}=\frac{\alpha \hat{k}_i/n}{\hat{k}_i}=\alpha/n.</annotation></semantics></math> This is a constant, and the expected value of that is just <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>α</mi><mi>/</mi><mi>n</mi></mrow><annotation encoding="application/x-tex">\alpha/n</annotation></semantics></math>. When you add this over all the null terms, you get <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>α</mi><mfrac><msub><mi>n</mi><mn>0</mn></msub><mi>n</mi></mfrac></mrow><annotation encoding="application/x-tex">\alpha\frac{n_0}{n}</annotation></semantics></math>, as desired. <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>◼</mi><annotation encoding="application/x-tex">\blacksquare</annotation></semantics></math></p>
<p>Here, we actually get a better bound than <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>α</mi><annotation encoding="application/x-tex">\alpha</annotation></semantics></math>, which might seem like a good thing, but also means we’re not making as many discoveries as we could be. We can correct for this by estimating <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msub><mi>n</mi><mn>0</mn></msub><annotation encoding="application/x-tex">n_0</annotation></semantics></math>, and then running BH with <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>α</mi><mfrac><mi>n</mi><msub><mi>n</mi><mn>0</mn></msub></mfrac></mrow><annotation encoding="application/x-tex">\alpha\frac{n}{n_0}</annotation></semantics></math>, so that the FDR for this procedure will be <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>≤</mo><mi>α</mi></mrow><annotation encoding="application/x-tex">\leq \alpha</annotation></semantics></math>.</p>
<p>Although we used independence here, we can make do without it, albeit at the cost of a logarithmic factor.</p>
<p><strong>Proposition 5.</strong> <em>When running Benjamini-Hochberg, we have <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mtext mathvariant="normal">FDR</mtext><mo>≤</mo><mi>α</mi><mfrac><msub><mi>n</mi><mn>0</mn></msub><mi>n</mi></mfrac><msub><mi>H</mi><mi>n</mi></msub></mrow><annotation encoding="application/x-tex">\text{FDR}\leq \alpha\frac{n_0}{n}H_n</annotation></semantics></math>.</em></p>
<p><em>Proof.</em> As before, we define a score <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msub><mi>s</mi><mi>i</mi></msub><annotation encoding="application/x-tex">s_i</annotation></semantics></math> for each <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msub><mi>p</mi><mi>i</mi></msub><annotation encoding="application/x-tex">p_i</annotation></semantics></math> that is 1 if <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>0</mn><mo>≤</mo><msub><mi>p</mi><mi>i</mi></msub><mo>≤</mo><mi>α</mi><mfrac><mn>1</mn><mi>n</mi></mfrac></mrow><annotation encoding="application/x-tex">0\leq p_i\leq \alpha \frac{1}{n}</annotation></semantics></math>, <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mfrac><mn>1</mn><mn>2</mn></mfrac><annotation encoding="application/x-tex">\frac{1}{2}</annotation></semantics></math> if <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>α</mi><mfrac><mn>1</mn><mi>n</mi></mfrac><mo>&lt;</mo><msub><mi>p</mi><mi>i</mi></msub><mo>≤</mo><mi>α</mi><mfrac><mn>2</mn><mi>n</mi></mfrac><mo>,</mo></mrow><annotation encoding="application/x-tex">\alpha\frac{1}{n}&lt;p_i\leq \alpha \frac{2}{n},</annotation></semantics></math> and so on, giving a score of 0 if <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>p</mi><mi>i</mi></msub><mo>&gt;</mo><mi>α</mi></mrow><annotation encoding="application/x-tex">p_i&gt;\alpha</annotation></semantics></math>.</p>
<p>We proved above that for a null <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>p</mi><annotation encoding="application/x-tex">p</annotation></semantics></math>-value, the expected score is <math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mfrac><mi>α</mi><mi>n</mi></mfrac><mrow><mo stretchy="true" form="prefix">(</mo><mn>1</mn><mo>+</mo><mi>⋯</mi><mo>+</mo><mfrac><mn>1</mn><mi>n</mi></mfrac><mo stretchy="true" form="postfix">)</mo></mrow><mi>.</mi></mrow><annotation encoding="application/x-tex">\frac{\alpha}{n}\left(1+\cdots+\frac{1}{n}\right).</annotation></semantics></math> Now, we write <math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mtext mathvariant="normal">FDR</mtext><mo>=</mo><munder><mo>∑</mo><mrow><mi>i</mi><mrow><mspace width="0.333em"></mspace><mtext mathvariant="normal"> null</mtext></mrow></mrow></munder><mstyle mathvariant="double-struck"><mi>𝔼</mi></mstyle><mrow><mo stretchy="true" form="prefix">[</mo><mfrac><mrow><mstyle mathvariant="bold"><mn>1</mn></mstyle><mo stretchy="false" form="prefix">{</mo><msub><mi>p</mi><mi>i</mi></msub><mrow><mspace width="0.333em"></mspace><mtext mathvariant="normal"> rejected</mtext></mrow><mo stretchy="false" form="postfix">}</mo></mrow><mrow><mo>max</mo><mo stretchy="false" form="prefix">(</mo><mn>1</mn><mo>,</mo><mover><mi>k</mi><mo accent="true">^</mo></mover><mo stretchy="false" form="postfix">)</mo></mrow></mfrac><mo stretchy="true" form="postfix">]</mo></mrow><mi>.</mi></mrow><annotation encoding="application/x-tex">\text{FDR}=\sum_{i\text{ null}} \mathbb{E}\left[\frac{\mathbf{1}\{p_i\text{ rejected}\}}{\max(1, \hat{k})}\right].</annotation></semantics></math> If <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msub><mi>p</mi><mi>i</mi></msub><annotation encoding="application/x-tex">p_i</annotation></semantics></math> is rejected, then <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>p</mi><mi>i</mi></msub><mo>≤</mo><mi>α</mi><mover><mi>k</mi><mo accent="true">^</mo></mover><mi>/</mi><mi>n</mi></mrow><annotation encoding="application/x-tex">p_i\leq \alpha \hat{k}/n</annotation></semantics></math>, so its score is <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>≥</mo><mn>1</mn><mi>/</mi><mover><mi>k</mi><mo accent="true">^</mo></mover></mrow><annotation encoding="application/x-tex">\geq 1/\hat{k}</annotation></semantics></math>. Put another way, <math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mfrac><mrow><mstyle mathvariant="bold"><mn>1</mn></mstyle><mo stretchy="false" form="prefix">{</mo><msub><mi>p</mi><mi>i</mi></msub><mrow><mspace width="0.333em"></mspace><mtext mathvariant="normal"> rejected</mtext></mrow><mo stretchy="false" form="postfix">}</mo></mrow><mrow><mo>max</mo><mo stretchy="false" form="prefix">(</mo><mn>1</mn><mo>,</mo><mover><mi>k</mi><mo accent="true">^</mo></mover><mo stretchy="false" form="postfix">)</mo></mrow></mfrac><mo>≤</mo><msub><mi>s</mi><mi>i</mi></msub><mi>.</mi></mrow><annotation encoding="application/x-tex">\frac{\mathbf{1}\{p_i\text{ rejected}\}}{\max(1, \hat{k})}\leq s_i.</annotation></semantics></math></p>
<p>Thus, <math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mtext mathvariant="normal">FDR</mtext><mo>≤</mo><munder><mo>∑</mo><mrow><mi>i</mi><mrow><mspace width="0.333em"></mspace><mtext mathvariant="normal"> null</mtext></mrow></mrow></munder><mstyle mathvariant="double-struck"><mi>𝔼</mi></mstyle><mo stretchy="false" form="prefix">[</mo><msub><mi>s</mi><mi>i</mi></msub><mo stretchy="false" form="postfix">]</mo><mo>=</mo><mi>α</mi><mfrac><msub><mi>n</mi><mn>0</mn></msub><mi>n</mi></mfrac><mrow><mo stretchy="true" form="prefix">(</mo><mn>1</mn><mo>+</mo><mi>⋯</mi><mo>+</mo><mfrac><mn>1</mn><mi>n</mi></mfrac><mo stretchy="true" form="postfix">)</mo></mrow><mi>.</mi><mi>◼</mi></mrow><annotation encoding="application/x-tex">\text{FDR}\leq \sum_{i\text{ null}} \mathbb{E}[s_i]=\alpha\frac{n_0}{n}\left(1+\cdots+\frac{1}{n}\right). \blacksquare</annotation></semantics></math></p>
</body>
</html>

  
  </article>

  </div>
  <div class="thefooter">
    <p>Made with Athena
    <br><br>Copyright, <i>2016</i></p>
  </div> <!-- footer end -->
</body>
</html>